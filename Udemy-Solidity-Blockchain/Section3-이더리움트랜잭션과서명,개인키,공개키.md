- 1이더(ether) = 10^18웨이(wei)

<br>
트랜잭션의 진정성 검증에 중요한 필드
- from: [account]<br>
- to: [account] (optional)<br>
- value: [integer] in wei<br>
<br>

**_트랜잭션 검증을 위해 '서명(Signature)'가 사용된다._**

서명이 만들어지는 흐름

- 개인키에 접근할 수 있어야 하기 때문에 트랜잭션 서명을 만들 수 있는 것.

- 대개 트랜잭션 서명 함수가 있다.

  - 형식은 'from, to, value, gas..' 파라미터가 있고 작동시키면 이전보다 많은 출력 결과를 얻게 되는데 추가로 얻게 된 'v, r, s' 필드를 이해하는 것이 중요하다.

  - v,r,s 파라미터를 통해 해당 트랜잭션이 악성 행위자로부터 온 것이 아니라는 것을 검증할 수 있다.

- 위 원리를 단계적으로 설명

  - 전형적인 트랜잭션 객체가 있다.
  - 메타마스크는 개인키를 저장한다.
  - 보통 사용자가 개인키를 보거나 접근할 수 없다.
  - 개인키는 32바이트 길이로 임의의 64 헥사코드 문자열로 이루어져 있다.
  - 그 후 '타원곡선 디지털서명 알고리즘(Ellipstic Curve Digital Signature Algorithm)'함수를 통해 개인키가 전송된다.
  - 이 함수(ECDSA)는 사용자에게 공개키를 준다.
  - 공개키의 가장 중요한 특성1: 개인키에서 공개키를 만들 수는 있지만 반대로 되돌릴 수는 없다.
  - 또한 공개키는 매우 길고 옵션도 많아 블록체인을 안전하게 보호한다.
  - 따라서 누구나 볼 수 있는 공개키를 가져도 개인키로 되돌릴 수 없다.
  - r,s 필드에서 ECRECOVER 함수를 통해 작동시킬 수 있으며, 다시 한 번 공개키와 이더리움 계정을 출력하게 된다.
  - 따라서 서명을 통해 해당 이더리움 트랜잭션의 진정성이 보장된다.
  - 서명이 있으면 공개키를 만들 수 있지만 개인키는 다시 만들 수 없다.
  - 공개키와 계정은 다시 만들 수 있고 트랜잭션의 'from' 필드에서 사용된 계정이 트랜잭션을 서명하고 트랜잭션 서명을 만들기 위해 사용된 기본 개인키를 갖고 있는 계정과 동일하다는 사실을 보장한다.

  **_이것이 바로 블록체인과 모든 참여 노드가 쉽게 트랜잭션의 검증할 수 있는 이유이다._**

  **서명은 개인키에서 생성, 공개키와 계정은 개인키에서 생성.**
